# (UN)INSTALL functions

import os, re, fileinput
from shutil import copyfile, move, rmtree
from PyQt5 import QtWidgets

import fdm_settings as s
from fdm_UI_helper import BoxDialog


# matlab scripts
MATLAB_CONVERT_SCRIPT = (
'''function [time] = fdm_convert_dcm_to_nii(working_folder, file, output_folder)
% GENERATED BY fdm.py
% Use spm12 to convert a .dcm file in working_folder into a .nii file. 
% Returns the time required for the conversion

% save & go to working path
cd_bkp = pwd;
cd(working_folder)

% check  that file is a .dcm
%if file(end-3:end) ~= '.dcm'
%    disp('ERROR');
%end

tic;
% convert
hdr = spm_dicom_headers(file);
spm_dicom_convert(hdr, 'all', 'flat', 'nii', output_folder);
cvt_time = toc;

time = cvt_time;

%  restore path
cd(cd_bkp)

end'''
)

MATLAB_ALIGN2_SCRIPT = (
'''function [time] = fdm_align2_nii(working_folder, file_ref, file_other)
% GENERATED BY fdm.py
% Use spm12 to align a pair of .nii files in working_folder. 
% Returns the time required for the alignment

% save & go to working path
cd_bkp = pwd;
cd(working_folder)


files = [file_ref;file_other];
tic;
spm_realign(files);
aln_time = toc;

time = aln_time;

%  restore path
cd(cd_bkp)

end''')

SPM_PREPROCESSING_BATCH = (
'''function [bidon] = preprocess_nii_edit(bidon)
disp(bidon)

clear matlabbatch

spm_jobman('initcfg');

matlabbatch{1}.spm.spatial.realign.write.data = {
                                                 ###FNII_FILES###
                                                 };
%%
matlabbatch{1}.spm.spatial.realign.write.roptions.which = [2 1];
matlabbatch{1}.spm.spatial.realign.write.roptions.interp = 4;
matlabbatch{1}.spm.spatial.realign.write.roptions.wrap = [0 0 0];
matlabbatch{1}.spm.spatial.realign.write.roptions.mask = 1;
matlabbatch{1}.spm.spatial.realign.write.roptions.prefix = 'r';
matlabbatch{2}.spm.spatial.coreg.estimate.ref = {###T1###};
matlabbatch{2}.spm.spatial.coreg.estimate.source(1) = cfg_dep('Realign: Reslice: Mean Image', substruct('.','val', '{}',{1}, '.','val', '{}',{1}, '.','val', '{}',{1}, '.','val', '{}',{1}), substruct('.','rmean'));
matlabbatch{2}.spm.spatial.coreg.estimate.other(1) = cfg_dep('Realign: Reslice: Resliced Images', substruct('.','val', '{}',{1}, '.','val', '{}',{1}, '.','val', '{}',{1}, '.','val', '{}',{1}), substruct('.','rfiles'));
matlabbatch{2}.spm.spatial.coreg.estimate.eoptions.cost_fun = 'nmi';
matlabbatch{2}.spm.spatial.coreg.estimate.eoptions.sep = [4 2];
matlabbatch{2}.spm.spatial.coreg.estimate.eoptions.tol = [0.02 0.02 0.02 0.001 0.001 0.001 0.01 0.01 0.01 0.001 0.001 0.001];
matlabbatch{2}.spm.spatial.coreg.estimate.eoptions.fwhm = [7 7];
matlabbatch{3}.spm.spatial.smooth.data(1) = cfg_dep('Coregister: Estimate: Coregistered Images', substruct('.','val', '{}',{2}, '.','val', '{}',{1}, '.','val', '{}',{1}, '.','val', '{}',{1}), substruct('.','cfiles'));
matlabbatch{3}.spm.spatial.smooth.fwhm = ###SMOOTH_FWHM###;
matlabbatch{3}.spm.spatial.smooth.dtype = 0;
matlabbatch{3}.spm.spatial.smooth.im = 0;
matlabbatch{3}.spm.spatial.smooth.prefix = 's';

spm_jobman('run',matlabbatch);
end''')

SPM_REGRESS_BATCH = (
'''function [bidon] = regress_fdm_edit(bidon)
disp(bidon)

spm_jobman('initcfg');

matlabbatch{1}.spm.stats.fmri_spec.dir = {###OUT_STATS###};
matlabbatch{1}.spm.stats.fmri_spec.timing.units = 'scans';
matlabbatch{1}.spm.stats.fmri_spec.timing.RT = 1.5;
matlabbatch{1}.spm.stats.fmri_spec.timing.fmri_t = 16;
matlabbatch{1}.spm.stats.fmri_spec.timing.fmri_t0 = 8;
%%
matlabbatch{1}.spm.stats.fmri_spec.sess.scans = {
                                                 ###SRFNII_FILES###
                                                 };
%%
matlabbatch{1}.spm.stats.fmri_spec.sess.cond = struct('name', {}, 'onset', {}, 'duration', {}, 'tmod', {}, 'pmod', {}, 'orth', {});
matlabbatch{1}.spm.stats.fmri_spec.sess.multi = {''};
matlabbatch{1}.spm.stats.fmri_spec.sess.regress.name = 'FD';
%%
matlabbatch{1}.spm.stats.fmri_spec.sess.regress.val = [###FD###
                                                       ];
%%
matlabbatch{1}.spm.stats.fmri_spec.sess.multi_reg = {''};
matlabbatch{1}.spm.stats.fmri_spec.sess.hpf = 128;
matlabbatch{1}.spm.stats.fmri_spec.fact = struct('name', {}, 'levels', {});
matlabbatch{1}.spm.stats.fmri_spec.bases.hrf.derivs = [0 0];
matlabbatch{1}.spm.stats.fmri_spec.volt = 1;
matlabbatch{1}.spm.stats.fmri_spec.global = 'None';
matlabbatch{1}.spm.stats.fmri_spec.mthresh = 0.8;
matlabbatch{1}.spm.stats.fmri_spec.mask = {''};
matlabbatch{1}.spm.stats.fmri_spec.cvi = 'AR(1)';
matlabbatch{2}.spm.stats.fmri_est.spmmat(1) = cfg_dep('fMRI model specification: SPM.mat File', substruct('.','val', '{}',{1}, '.','val', '{}',{1}, '.','val', '{}',{1}), substruct('.','spmmat'));
matlabbatch{2}.spm.stats.fmri_est.write_residuals = 0;
matlabbatch{2}.spm.stats.fmri_est.method.Classical = 1;
matlabbatch{3}.spm.stats.con.spmmat(1) = cfg_dep('Model estimation: SPM.mat File', substruct('.','val', '{}',{2}, '.','val', '{}',{1}, '.','val', '{}',{1}), substruct('.','spmmat'));
matlabbatch{3}.spm.stats.con.consess{1}.tcon.name = 'FD effect';
matlabbatch{3}.spm.stats.con.consess{1}.tcon.weights = [1 0];
matlabbatch{3}.spm.stats.con.consess{1}.tcon.sessrep = 'none';
matlabbatch{3}.spm.stats.con.delete = 0;
matlabbatch{4}.spm.stats.results.spmmat(1) = cfg_dep('Contrast Manager: SPM.mat File', substruct('.','val', '{}',{3}, '.','val', '{}',{1}, '.','val', '{}',{1}), substruct('.','spmmat'));
matlabbatch{4}.spm.stats.results.conspec.titlestr = '';
matlabbatch{4}.spm.stats.results.conspec.contrasts = 1;
matlabbatch{4}.spm.stats.results.conspec.threshdesc = 'FWE';
matlabbatch{4}.spm.stats.results.conspec.thresh = 0.1;
matlabbatch{4}.spm.stats.results.conspec.extent = 0;
matlabbatch{4}.spm.stats.results.conspec.conjunction = 1;
matlabbatch{4}.spm.stats.results.conspec.mask.none = 1;
matlabbatch{4}.spm.stats.results.units = 1;
matlabbatch{4}.spm.stats.results.export{1}.ps = true;
spm_jobman('run',matlabbatch);

end''')


def popup_installer():
    if openNFT_present() and not check_installed_openNFT():
        installdialog = BoxDialog(message_title = "Install FDM for OpenNFT", message = "OpenNFT.py has been detected. Do you want to install FDM ?",buttons =  QtWidgets.QMessageBox.Ok | QtWidgets.QMessageBox.Cancel, detailed = "After installation, just launch OpenNFT as you usually do to see the new MC plots.", title="FDM install")
        ret = installdialog.exec_()
        if ret == 1024:
            print("installing")
            install_OpenNFT()
    if not check_installed_matlab_scripts():
        installdialog = BoxDialog(message_title = "Install stand alone FDM", message = "FDM requires unpacking matlab scripts to work. Do you want to generate the scripts in folder {} ? (if not, the program will quit)".format(s.FDM_PATH),buttons =  QtWidgets.QMessageBox.Ok | QtWidgets.QMessageBox.Cancel, detailed = "The installation destination folder can be edited in fdm.py", title="FDM install")
        ret = installdialog.exec_()
        if ret == 1024:
            print("installing")
            install_matlab_scripts()
        else:
            print("Nothing to do. Quitting...")
            exit()

def no_confirm_installer():
    if openNFT_present() and not check_installed_openNFT():
            print("Installing FDM for OpenNFT")
            install_OpenNFT()
    if not check_installed_matlab_scripts():
            print("Installing stand alone FDM")
            install_matlab_scripts()

def check_installed_matlab_scripts():
    if not (os.path.isfile(s.MATLAB_CONVERT_PATH) and os.path.isfile(s.MATLAB_ALIGN2_PATH) and os.path.isfile(s.SPM_PREPROCESSING_BATCH_PATH) and os.path.isfile(s.SPM_REGRESS_BATCH_PATH)):
        print("spm12 script do not exist.")
        return False
    return True

def openNFT_present():
    # TODO : check specific version of OpenNFT
    if not os.path.isfile(s.OPENNFT_PATH):
        print("OpenNFT not detected in root folder. Only standalone mode is available.")
        return False
    return True

def check_installed_openNFT():       
    if openNFT_present():
        if s.OPENNFT_EDITED_BLOCK_START in open(s.OPENNFT_PATH).read():
           return True
        return False

def install_matlab_scripts():
    if check_installed_matlab_scripts():
        print("SPM scripts already installed.")
        return
    
    # makedir if doesn't exist
    os.makedirs(s.MATLAB_FUNCTIONS_PATH, exist_ok=True)
    
    with open(s.MATLAB_CONVERT_PATH, "w") as f:
        print("============="+ s.MATLAB_CONVERT_PATH)
        f.write(MATLAB_CONVERT_SCRIPT)

    with open(s.MATLAB_ALIGN2_PATH, "w") as f:
        f.write(MATLAB_ALIGN2_SCRIPT)

    with open(s.SPM_PREPROCESSING_BATCH_PATH, "w") as f:
        f.write(SPM_PREPROCESSING_BATCH)

    with open(s.SPM_REGRESS_BATCH_PATH, "w") as f:
        f.write(SPM_REGRESS_BATCH)
    
    print("SPM scripts created in spm folder.")
    
def install_OpenNFT():
    if check_installed_openNFT():
        print("OpenNFT already installed.")
        return
    
    # backup openNFT
    os.makedirs(s.FDM_PATH, exist_ok=True)
    copyfile(s.OPENNFT_PATH, os.path.join(s.FDM_PATH, 'OpenNFT.py.backup'))
    print("Making a backup of OpenNFT.py")
    
    replace_dict = {                   
                    'self.mcPlot = self.createMcPlot()' : 'self.fdmod = fdm.fd_OpenNFT(self)%%self.mcPlot = self.fdmod.createMcPlot()',
                    'self.drawMcPlots(init)'            : 'self.fdmod.drawMcPlots(init)',
                    'for f in files:'                   : 'for f in sorted(files):'
                    }
    append_dict = {'import sys'                         : 'import fdm',
                   'plotWidget = obj.getViewWidget()'   : 'p = plotWidget.getPlotItem()%%if p.vb.name == "MC":%%    self.fdmod.createwindow()%%    return True'
                   }

    # Read in the file
    file = ""
    r = re.compile("([ \t]*)(.+)")
    
    with fileinput.FileInput(s.OPENNFT_PATH, inplace=True, backup='.bak') as file:
    #with fileinput.FileInput(OPENNFT_PATH) as file:
        for line in file:
            indent_line = r.match(line)
            if indent_line is not None:
                nli = "\n" + indent_line.group(1)
                if indent_line.group(2) in replace_dict:
                    line = nli + s.OPENNFT_EDITED_BLOCK_START
                    line += nli + "#" + indent_line.group(2)
                    tmp = replace_dict[indent_line.group(2)].replace("%%", nli)
                    line += nli + tmp
                    line += nli + s.OPENNFT_EDITED_BLOCK_END + "\n"
                elif indent_line.group(2) in append_dict:
                    line += nli + s.OPENNFT_EDITED_BLOCK_START + nli + append_dict[indent_line.group(2)].replace("%%", nli) + nli + s.OPENNFT_EDITED_BLOCK_END + "\n\n"
            print(line, end='')
            
def uninstall():
    bckp_f = os.path.join(s.FDM_PATH, 'OpenNFT.py.backup')
    if os.path.isfile(bckp_f):
        move(bckp_f, s.OPENNFT_PATH)
        print("Reverted to OpenNFT.py before fdm installation")
    else:
        print("Backup file {} not found in fdm folder. Cannot uninstall. Please replace OpenNFT.py by a fresh version manually.")
    
    if os.path.isfile(s.MATLAB_CONVERT_PATH):
        os.unlink(s.MATLAB_CONVERT_PATH)
    if os.path.isfile(s.MATLAB_ALIGN2_PATH):
        os.unlink(s.MATLAB_ALIGN2_PATH)
    if os.path.isfile(s.SPM_PREPROCESSING_BATCH_PATH):
        os.unlink(s.SPM_PREPROCESSING_BATCH_PATH)
    if os.path.isfile(s.SPM_REGRESS_BATCH_PATH):
        os.unlink(s.SPM_REGRESS_BATCH_PATH)
    print("Deleted spm scripts")
    
    if not os.listdir(s.FDM_PATH):
        rmtree(s.FDM_PATH)
        print("Deleted empty fdm directory")
    else :
        print("Manually created files in fdm directory have been preserved.")

if __name__ == "__main__":
        no_confirm_installer()